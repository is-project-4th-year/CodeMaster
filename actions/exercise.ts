'use server';

import { createClient } from '@/lib/supabase/server';
import { ApiResponse, CreateExerciseInput, ExerciseWithRelations } from '@/types/exercise';
import { revalidatePath } from 'next/cache';


/**
 * Create a new exercise with tags and test cases
 */
export async function createExercise(
  input: CreateExerciseInput
): Promise<ApiResponse<ExerciseWithRelations>> {
  try {
    const supabase = await createClient();

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return { error: 'Unauthorized' };
    }

    // Calculate points based on rank
    const pointsMap: Record<number, number> = {
      8: 10, 7: 20, 6: 30, 5: 50, 4: 80, 3: 120, 2: 180, 1: 250
    };
    const points = pointsMap[input.rank] || 10;

    // Insert exercise (ID and URL will be auto-generated by database)
    const { data: exercise, error: exerciseError } = await supabase
      .from('exercises')
      .insert({
        name: input.name,
        category: input.category,
        description: input.description,
        rank: input.rank,
        rank_name: input.rank_name,
        solutions: input.solutions,
        points: points,
      })
      .select()
      .single();

    if (exerciseError) {
      console.error('Exercise creation error:', exerciseError);
      return { error: exerciseError.message };
    }

    const exerciseId = exercise.id;

    // Insert tags
    if (input.tags.length > 0) {
      const tagsToInsert = input.tags.map(tag => ({
        exercise_id: exerciseId,
        tag: tag
      }));

      const { error: tagsError } = await supabase
        .from('exercise_tags')
        .insert(tagsToInsert);

      if (tagsError) {
        console.error('Tags insertion error:', tagsError);
        // Continue even if tags fail
      }
    }

    // Insert test cases
    if (input.test_cases.length > 0) {
      const testCasesToInsert = input.test_cases.map((tc, index) => ({
        exercise_id: exerciseId,
        input: tc.input,
        expected_output: tc.expected_output,
        description: tc.description,
        order_index: tc.order_index || index + 1,
        is_hidden: tc.is_hidden || false,
      }));

      const { error: testCasesError } = await supabase
        .from('test_cases')
        .insert(testCasesToInsert);

      if (testCasesError) {
        console.error('Test cases insertion error:', testCasesError);
        return { error: testCasesError.message };
      }
    }

    // Fetch complete exercise with relations
    const result = await getExerciseById(exerciseId);
    
    revalidatePath('/admin/exercises');
    revalidatePath('/exercises');

    return result;
  } catch (error) {
    console.error('Unexpected error:', error);
    return { error: 'Failed to create exercise' };
  }
}

/**
 * Update an existing exercise
 */
export async function updateExercise(
  id: string,
  updates: Partial<CreateExerciseInput>
): Promise<ApiResponse<ExerciseWithRelations>> {
  try {
    const supabase = await createClient();

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return { error: 'Unauthorized' };
    }

    // Update exercise
    if (updates.name || updates.description || updates.category || updates.rank) {
      const { error: exerciseError } = await supabase
        .from('exercises')
        .update({
          name: updates.name,
          description: updates.description,
          category: updates.category,
          rank: updates.rank,
          rank_name: updates.rank_name,
          solutions: updates.solutions,
        })
        .eq('id', id);

      if (exerciseError) {
        return { error: exerciseError.message };
      }
    }

    // Update tags if provided
    if (updates.tags) {
      // Delete existing tags
      await supabase
        .from('exercise_tags')
        .delete()
        .eq('exercise_id', id);

      // Insert new tags
      if (updates.tags.length > 0) {
        const tagsToInsert = updates.tags.map(tag => ({
          exercise_id: id,
          tag: tag
        }));

        await supabase
          .from('exercise_tags')
          .insert(tagsToInsert);
      }
    }

    // Update test cases if provided
    if (updates.test_cases) {
      // Delete existing test cases
      await supabase
        .from('test_cases')
        .delete()
        .eq('exercise_id', id);

      // Insert new test cases
      if (updates.test_cases.length > 0) {
        const testCasesToInsert = updates.test_cases.map((tc, index) => ({
          exercise_id: id,
          input: tc.input,
          expected_output: tc.expected_output,
          description: tc.description,
          order_index: tc.order_index || index + 1,
          is_hidden: tc.is_hidden || false,
        }));

        await supabase
          .from('test_cases')
          .insert(testCasesToInsert);
      }
    }

    revalidatePath('/admin/exercises');
    revalidatePath('/exercises');

    return await getExerciseById(id);
  } catch (error) {
    console.error('Unexpected error:', error);
    return { error: 'Failed to update exercise' };
  }
}

/**
 * Delete an exercise
 */
export async function deleteExercise(id: string): Promise<ApiResponse<null>> {
  try {
    const supabase = await createClient();

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return { error: 'Unauthorized' };
    }

    const { error } = await supabase
      .from('exercises')
      .delete()
      .eq('id', id);

    if (error) {
      return { error: error.message };
    }

    revalidatePath('/admin/exercises');
    revalidatePath('/exercises');

    return { data: null };
  } catch (error) {
    console.error('Unexpected error:', error);
    return { error: 'Failed to delete exercise' };
  }
}

/**
 * Get a single exercise with all relations
 */
export async function getExerciseById(
  id: string
): Promise<ApiResponse<ExerciseWithRelations>> {
  try {
    const supabase = await createClient();
console.log('Fetching exercise with ID:', id);
    // Fetch exercise
    const { data: exercise, error: exerciseError } = await supabase
      .from('exercises')
      .select('*')
      .eq('id', id)
      .single();

    if (exerciseError) {
      return { error: exerciseError.message };
    }

    // Fetch tags
    const { data: tags } = await supabase
      .from('exercise_tags')
      .select('tag')
      .eq('exercise_id', id);

    // Fetch test cases
    const { data: testCases } = await supabase
      .from('test_cases')
      .select('*')
      .eq('exercise_id', id)
      .order('order_index', { ascending: true });

    return {
      data: {
        ...exercise,
        tags: tags?.map(t => t.tag) || [],
        test_cases: testCases || [],
      }
    };
  } catch (error) {
    console.error('Unexpected error:', error);
    return { error: 'Failed to fetch exercise' };
  }
}

/**
 * Get all exercises with pagination
 */
export async function getExercises(
  page = 1,
  limit = 20,
  category?: string
): Promise<ApiResponse<{ exercises: ExerciseWithRelations[]; total: number }>> {
  try {
    const supabase = await createClient();
    const from = (page - 1) * limit;
    const to = from + limit - 1;

    let query = supabase
      .from('exercises')
      .select('*', { count: 'exact' });

    if (category) {
      query = query.eq('category', category);
    }

    const { data: exercises, error, count } = await query
      .range(from, to)
      .order('created_at', { ascending: false });

    if (error) {
      return { error: error.message };
    }

    // Fetch tags for all exercises
    const exerciseIds = exercises?.map(e => e.id) || [];
    const { data: allTags } = await supabase
      .from('exercise_tags')
      .select('exercise_id, tag')
      .in('exercise_id', exerciseIds);

    // Fetch test case counts
    const { data: testCaseCounts } = await supabase
      .from('test_cases')
      .select('exercise_id')
      .in('exercise_id', exerciseIds);

    // Group tags by exercise_id
    const tagsByExercise = (allTags || []).reduce((acc, { exercise_id, tag }) => {
      if (!acc[exercise_id]) acc[exercise_id] = [];
      acc[exercise_id].push(tag);
      return acc;
    }, {} as Record<string, string[]>);

    // Count test cases by exercise_id
    const testCaseCountByExercise = (testCaseCounts || []).reduce((acc, { exercise_id }) => {
      acc[exercise_id] = (acc[exercise_id] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const exercisesWithRelations = exercises?.map(exercise => ({
      ...exercise,
      tags: tagsByExercise[exercise.id] || [],
      test_cases: [], // Don't load all test cases for list view
      test_case_count: testCaseCountByExercise[exercise.id] || 0,
    })) || [];

    return {
      data: {
        exercises: exercisesWithRelations as any,
        total: count || 0,
      }
    };
  } catch (error) {
    console.error('Unexpected error:', error);
    return { error: 'Failed to fetch exercises' };
  }
}

/**
 * Generate a unique exercise ID
 */
export async function generateExerciseId(): Promise<string> {
  // This is now handled by the database auto-increment
  // Function kept for backwards compatibility but not needed
  return '';
}